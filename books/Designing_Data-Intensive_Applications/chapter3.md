# Chapter 3

ストレージと抽出

*自分のアプリに適したエンジンを選択できないといけない*

はじめに扱う2つのエンジン

* **log-structured**ストレージエンジン
* **ページ指向**のストレージエンジン (Bツリーなど)

-----

## 3.1 データベースを駆動するデータ構造

"インデックスを追加するとクエリが改善されるが書き込みが遅くなる"

これは、ストレージシステムにおける重要なトレードオフである。

-----

### 3.1.1 ハッシュインデックス

- データストレージではファイルへの**追記だけ**を行う
- インメモリのハッシュマップ中には、すべてのキーに対してデータファイル中のバイトオフセットをマッピングする。
- すべてのキーが利用可能なRAMに収まっている必要がある。

【課題】追記されディスクを使い切らないようにどうするか

---

![External Image](assets/chapter3_3-1.jpg)

---

- コンパクション処理をする。
  - ログ中で重複しているキーを捨て、それぞれのキーに対する最新の情報だけを残す処理

![External Image](assets/chapter3_3-2.jpg)

---

- コンパクションとマージを一緒に行う。
  - 複数のセグメントを1つにする。
  - 古いセグメントを参照させながらバックグラウンドで処理ができ、完了したら切り替えて古い方は削除する。

![External Image](assets/chapter3_3-3.jpg)

---

- キーに対する値を見つけるには
  1.  最新のセグメントのハッシュマップをチェック
  2.  もしキーがなければ、2番めに新しいセグメントを探しにいく、を繰り返す。

--- 

- **追加だけ**の利点
  - 書き込みは常にシーケンシャルであり、これは概してランダムな書き込みよりもはるかに高速。
  - 並行処理とクラッシュリカバリは、セグメントファイルが追記のみあるいはイミュータブルであれば非常にシンプルになる。
    - 上書き中にクラッシュした場合はファイルが断片的に不整合になるという問題がある。
  - 古いセグメントをマージすることで、データファイルが時間とともにフラグメンテーションを起こす問題を避けることができる。

----- 

### 3.1.2 SSTableとLSMツリー

セグメントにて**キーでソートされている**条件を加える。このフォーマットはSorted String Table、あるいは短くSSTableと呼ばれる。

---

- SSTableの利点
  - セグメントのマージをシンプルに効率的に行える
    - マージソートのアルゴリズムと似ている。
  - ファイル中の特定のキーを探す際にすべてのキーをメモリに保持しなくても効率的にValueにあたるオフセットを探すことができる。
    - 複数キーをブロックとしてグループ化して圧縮してディスクに置くことでディスク削減とI/O帯域削減ができる。

--- 

#### 3.1.2.1 SSTableの構築と管理

SSTableへキーを書き込むために、ツリー型のデータ構造が採用される。

---

以下の動作をするツリー型データ構造を持つストレージエンジンを構築する。

- 書き込み要求がきたらインメモリのバランスドツリーデータ構造へ追加する。このインメモリツリーは*memtable*と呼ばれる。
- memtableから大きくなったときはSSTableファイルとしてディスクに書き出す。
- 読み取り時ははじめにmemtableを見に行きその次にディスク上のSSTable(セグメント)、次に古いセグメントを探す。
- 時おりマージとコンパクションのプロセスをバックグラウンドで実行する。

---

【クラッシュ異常時】データベースのクラッシュ時にインメモリのmemtableを守る方法として書き込み時にディスク上に別個のログをもたせておき、リカバリにそのログからmemtableを再生させる。

--- 

上述のようなインデックス構造はLog-Structured Merge-Tree (LSMツリー) と呼ばれる

Luceneでは、キーを語(term)、値をそのtermを含むすべてのドキュメントのIDリスト(ポスティングリスト)とするキーバリュー構造を使って実装されている。

Luceneでは、termからポスティングリストへのマッピングはSSTableに似たソート済みのファイルに保存される。

---

#### 3.1.2.3 パフォーマンスの最適化

- **ブルームフィルタ**であるキーがデータベース中に存在しないことがわかり、不要なディスク読み取りを避けることができる。
- **サイズごと**及び**階層ごと**のコンパクションという戦略の違いがある。

-----

### 3.1.3 B Tree

- Bツリーにおける1ページ内の子ページの参照数は**分岐係数(brancing factor)**と呼ばれる。実際には、分岐係数はページの参照と範囲の境界を保存するのに必要な領域に依存するが通常は**数百程度**である。
- n個のキーを持つBツリーの深さは常にO(logn)になる。
  - 【具体】ページサイズが4KBで深さが4レベルであり、分岐係数が500のツリーでは最大で**256TB**を保存できる。
    - ((1 * 500 * 500 * 500 * 500 ) *  4[KB] ) / 1000 / 1000 / 1000 = 250 [TB]

---

#### 3.1.3.1 Bツリーの信頼性を高める

- Bツリーは上書き処理なので処理中にクラッシュがある場合追加処理よりも面倒
  - ディスク上に追加の構造化データをもたせるクラッシュ時はそこから不整合なツリーを回復させる。
- 並行処理に対して制御が必要になる。
  - ツリーのデータ構造をラッチ(軽量なロック)で保護する。

-----

### 3.1.4 BツリーとLSMツリーの比較

- LSMツリーは書き込みが高速であり、Bツリーは読み取りが高速である。 
  - LSMツリーの読み取りが遅いのは、様々なコンパクションのステージおいて複数のデータ構造やSSTableを調べる必要があるため。
  - Bツリーが書き込みが遅いのは、更新と同時に上書き処理と再構築が必要になるため。

-----

### 3.1.5 その他のインデックス構造

**セカンダリーインデックス**

キーがユニークではないという特徴がある。以下の2つのどちらかをする。

0. インデックス内のそれぞれの値を全文検索エンジンのようにマッチする行の識別子のリストにすること
0. キーに行の識別子を追加することでユニークにすること

---

#### 3.1.5.1 インデックスへの値への保存

インデックス中のキーは、(目的の行へのポインタ, 他の参照行へのポインタ)のどちらか

他の参照行が保存されている場所は**ヒープファイル**と呼ばれる。

[課題] 状況によってはヒープファイルに至る過程でホップ数が大きくなることは読み取りパフォーマンスの負担になる。

---

インデックス付けされた行を直接インデックス内に保存する(複製を持つ)方が望ましいこともある。

これを**クラスタ化インデックス**と呼ぶ。

MySQLのInnoDBでは、テーブルのプライマリーキーは必ずクラスタ化インデックスになっている(らしい)。

中間的なものにカバリングインデックスがあり、これはテーブルの一部の列だけをインデックスに保存する。

---

#### 3.1.5.2 複合インデックス

WEBサイトにて(赤、緑、青)という3次元のインデックスを使い、特定の**範囲内**の色製品の検索をしたりできる。

空間検索で多次元インデックスが考慮され、Rツリーのような特化した空間インデックスを使う方法がある。

#### 3.1.5.3 全文検索と曖昧インデックス

クエリ中の誤字に対応するために、Luceneは特定の編集距離内にある語をテキストから検索できるようになっている。

(編集距離が1とは1つの文字が追加、削除、あるいは置換されているという意味)

---

Luceneのメモリインデックスは、**TRIE木(トライ木)**に似たキー内の文字に対する有限状態オートマトンである。

このオートマトンは与えられた編集距離内にある語の効率的な検索をサポートする**レーベンシュタインオートマトン**に変換できる。

---

他の曖昧検索の手法は、ドキュメントのクラシフィケーションや機械学習の方向に向かっていく。詳細は情報抽出に関する教科書を参照。

#### 3.1.5.4 全データのメモリでの保持

インメモリデータベースの台頭

直感に反するが、インメモリデータベースのパフォーマンス上のメリットはディスク読み取りをしないことによるものではない。ディスクベースでもメモリが多ければOSがメモリキャッシュをするため。

インメモリデータベースが高速なのはむしろメモリ内のデータ構造をディスクに書き込める形式にエンコードするというオーバーヘッドを回避できることによる。

---

パフォーマンス以外の観点では、インメモリデータベースはディスクベースのインデックスでは実装が難しいデータモデルを提供できる。

例えば、Redis(インメモリDB)はプライオリティキューや集合といった様々なデータ構造に対するデータベースのようなインタフェースを提供する。

-----

## 3.2 トランザクション処理か、分析処理か？

* OnLine Transaction Processing (OLTP)
* OnLine Analytic Processing (OATP)

-----

### 3.2.2 スターとスノーフレーク :を 分析のためのスキーマ

**スタースキーマ(ディメンションモデル)**

中心にあるのが**ファクトテーブル** (例: 顧客の商品購入)。1つのイベントを表す。

ファクトテーブルの他の列は、**ディメンションテーブル**と呼ばれる他のテーブルを参照する外部キーになっている。ディメンションはそのイベントの人物、対象、日時、場所、方法、理由といったことを表す。

---

スターモデルのバリエーションの1つに**スノーフレークスキーマ**がある。

ディメンションがさらにサブディメンションに分割される。

## 3.3 列指向ストレージ

**列指向ストレージ**は、それぞれの列に含まれるすべての値をまとめて保存する。

![External Image](assets/chapter3_3-10.jpg)

列指向のストレージレイアウトでは、それぞれの列のファイルが同じ順序で行を保持していなければならない。

### 3.3.1 列の圧縮

列指向ストレージは圧縮に適していることが多い。

![External Image](assets/chapter3_3-11.jpg)

---

具体的なクエリ

```
WHERE product_sk IN (30, 68, 69):
```

product_sk = 30 ,product_sk = 68, product_sk = 69 に対応する3つのビットマップをロードし、それらのビットごとのORを取ることで対象の行がわかる。この処理はビット演算によりCPU上できわめて効率的に行える。 

この手法は**ベクトル化処理(vectorized processing)**と呼ばれる。

#### 3.3.1.1 メモリの帯域とベクトル化処理

データウェアハウス(列指向)のクエリではその処理をCPUのSIMD命令を効率的に利用する。

クエリエンジンはCPUのL1キャッシュにうまく収まる圧縮された列のデータのチャンクを取り、密なループ内で処理を繰り返す。CPUは大量の関数呼び出しや分岐処理が必要なループに比べてこういったループをはるかに高速に実行できる。

### 3.3.2 列ストレージにおけるソート順序

ソート順序のキーを指定する1つの利点は、列の圧縮を助けることができること。

---

#### 3.3.2.1 複数のソート順序

Verticaは同じデータをいくつかの異なる方法で保存する。

-----

### 3.3.3 列指向ストレージへの書き込み

書き込みのパフォーマンスのために列指向データベースでもLSMツリーと同様になる。

すべての書き込みはまずインメモリストアに送られ、そこでソート済みの構造に追加されてディスクへの書き込みに備えられる。十分な書き込みが蓄積されたら、それらはディスク上の列ファイルとマージされ、一度に新しいファイルに書き出される。

クエリオプティマイザはディスク上の列データとメモリ内の直近の書き込みの両方を調べることになるが、この区別をユーザーからは見えないようにしてくれる。