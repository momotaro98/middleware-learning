# Chapter 3

ストレージと抽出

*自分のアプリに適したエンジンを選択できないといけない*

はじめに扱う2つのエンジン

* **log-structured**ストレージエンジン
* **ページ指向**のストレージエンジン (Bツリーなど)

-----

## 3.1 データベースを駆動するデータ構造

"インデックスを追加するとクエリが改善されるが書き込みが遅くなる"

これは、ストレージシステムにおける重要なトレードオフである。

-----

### 3.1.1 ハッシュインデックス

- データストレージではファイルへの**追記だけ**を行う
- インメモリのハッシュマップ中には、すべてのキーに対してデータファイル中のバイトオフセットをマッピングする。
- すべてのキーが利用可能なRAMに収まっている必要がある。

【課題】追記されディスクを使い切らないようにどうするか

---

TODO: 図

---

- コンパクション処理をする。
  - ログ中で重複しているキーを捨て、それぞれのキーに対する最新の情報だけを残す処理

TODO: 図

---

- コンパクションとマージを一緒に行う。
  - 複数のセグメントを1つにする。
  - 古いセグメントを参照させながらバックグラウンドで処理ができ、完了したら切り替えて古い方は削除する。

TODO: 図

---

- キーに対する値を見つけるには
  1.  最新のセグメントのハッシュマップをチェック
  2.  もしキーがなければ、2番めに新しいセグメントを探しにいく、を繰り返す。

--- 

- **追加だけ**の利点
  - 書き込みは常にシーケンシャルであり、これは概してランダムな書き込みよりもはるかに高速。
  - 並行処理とクラッシュリカバリは、セグメントファイルが追記のみあるいはイミュータブルであれば非常にシンプルになる。
    - 上書き中にクラッシュした場合はファイルが断片的に不整合になるという問題がある。
  - 古いセグメントをマージすることで、データファイルが時間とともにフラグメンテーションを起こす問題を避けることができる。

----- 

### 3.1.2 SSTableとLSMツリー

セグメントにて**キーでソートされている**条件を加える。このフォーマットはSorted String Table、あるいは短くSSTableと呼ばれる。

---

- SSTableの利点
  - セグメントのマージをシンプルに効率的に行える
    - マージソートのアルゴリズムと似ている。
  - ファイル中の特定のキーを探す際にすべてのキーをメモリに保持しなくても効率的にValueにあたるオフセットを探すことができる。
    - 複数キーをブロックとしてグループ化して圧縮してディスクに置くことでディスク削減とI/O帯域削減ができる。

--- 

#### 3.1.2.1 SSTableの構築と管理

SSTableへキーを書き込むために、ツリー型のデータ構造が採用される。

---

以下の動作をするツリー型データ構造を持つストレージエンジンを構築する。

- 書き込み要求がきたらインメモリのバランスドツリーデータ構造へ追加する。このインメモリツリーは*memtable*と呼ばれる。
- memtableから大きくなったときはSSTableファイルとしてディスクに書き出す。
- 読み取り時ははじめにmemtableを見に行きその次にディスク上のSSTable(セグメント)、次に古いセグメントを探す。
- 時おりマージとコンパクションのプロセスをバックグラウンドで実行する。

---

【クラッシュ異常時】データベースのクラッシュ時にインメモリのmemtableを守る方法として書き込み時にディスク上に別個のログをもたせておき、リカバリにそのログからmemtableを再生させる。

--- 

上述のようなインデックス構造はLog-Structured Merge-Tree (LSMツリー) と呼ばれる

Luceneでは、キーを語(term)、値をそのtermを含むすべてのドキュメントのIDリスト(ポスティングリスト)とするキーバリュー構造を使って実装されている。

Luceneでは、termからポスティングリストへのマッピングはSSTableに似たソート済みのファイルに保存される。

---

#### 3.1.2.3 パフォーマンスの最適化

- **ブルームフィルタ**であるキーがデータベース中に存在しないことがわかり、不要なディスク読み取りを避けることができる。
- **サイズごと**及び**階層ごと**のコンパクションという戦略の違いがある。

-----

### 3.1.3 B Tree

- Bツリーにおける1ページ内の子ページの参照数は**分岐係数(brancing factor)**と呼ばれる。実際には、分岐係数はページの参照と範囲の境界を保存するのに必要な領域に依存するが通常は**数百程度**である。
- n個のキーを持つBツリーの深さは常にO(logn)になる。
  - 【具体】ページサイズが4KBで深さが4レベルであり、分岐係数が500のツリーでは最大で**256TB**を保存できる。
    - ((1 * 500 * 500 * 500 * 500 ) *  4[KB] ) / 1000 / 1000 / 1000 = 250 [TB]

---

#### 3.1.3.1 Bツリーの信頼性を高める

- Bツリーは上書き処理なので処理中にクラッシュがある場合追加処理よりも面倒
  - ディスク上に追加の構造化データをもたせるクラッシュ時はそこから不整合なツリーを回復させる。
- 並行処理に対して制御が必要になる。
  - ツリーのデータ構造をラッチ(軽量なロック)で保護する。

-----

### 3.1.4 BツリーとLSMツリーの比較

- LSMツリーは書き込みが高速であり、Bツリーは読み取りが高速である。 
  - LSMツリーの読み取りが遅いのは、様々なコンパクションのステージおいて複数のデータ構造やSSTableを調べる必要があるため。
  - Bツリーが書き込みが遅いのは、更新と同時に上書き処理と再構築が必要になるため。

-----

### 3.1.5 その他のインデックス構造

#### 3.1.5.1 インデックスへの値への保存

#### 3.1.5.2 複合インデックス

#### 3.1.5.3 全文検索と曖昧インデックス

#### 3.1.5.4 全データのメモリでの保持

-----

## 3.2 トランザクション処理か、分析処理か？

