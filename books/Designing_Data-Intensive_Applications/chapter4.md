# Chapter 3

エンコーディングと進化

-----

新旧データフォーマットがシステム内で共存するときにスムーズに動作し続けるために互換性が必要。

* **後方互換性** From古いコード
  * 古いコードによって書かれたデータを新しいコードが読めること
* **前方互換性** From新しいコード
  * 新しいコードによって書かれたデータを古いコードが読めること

-----

## 4.1 データエンコードのフォーマット

<重要> データというものは以下の2つの異なる表現で扱われる。

1. メモリ内にてオブジェクト、リスト、配列、ツリーなどで保持される。これらのデータ構造はCPUによるアクセス操作が効率的になるようになっている。(通常はポインタ)

2. ファイルにデータを書いたり、ネットワーク経由でデータを送信する場合は、データは何らかのバイトの並びとしてエンコードされている必要がある。

-----

1.を2.にすることをエンコード(シリアライズ, マーシャル)と呼び、2.を1.にすることをデコード(パース, デシリアライズ, アンマーシャル)と呼ぶ。

-----

### 4.1.1 言語固有のフォーマット

ごく一時的な場合を除けば、特定の言語の組み込みをエンコードに使うのは良くない考えである。

-----

### 4.1.2 JSON, XML, 様々なバイナリフォーマット

JSONドキュメントをバイナリエンコードすると、その中のどこかにfield名の文字列を含める必要がある。

-----

### 4.1.3 ThriftとProtocol Buffers

ThriftとProtocol Buffersはどちらも同じ原理に基づくバイナリエンコーディングライブラリである。どちらもエンコードするためのデータに対するスキーマを必要とする。

---

Thriftの定義言語

```
struct Person {
    1: required string userName,
    2: optional i64 favoriteNumber,
    3: optional list<string> interests
}
```

---

TODO: pic1

---

Protocol Buffersの定義言語

```
message Person {
    required string user_name       = 1;
    optional int634 favorite_number = 2;
    repeated string interests       = 3;
}
```

---

TODO: pic2

---

#### 4.1.3.1 フィールドタグとスキーマの進化

**スキーマの進化 (schema evolution)** スキーマが時間の経過とともに変化せざるを得ない。

Thrift, Protocol Buffersにおいて、フィールドのタグ(1,2,3...)は変更できない。これはタグを変更するとエンコード済みの既存の全データが不正なものになるため。

新しいタグ番号を使う限りにおいて、スキーマには新しいフィールドを加えることできる。

---

#### 4.1.3.2 データ型とスキーマの進化