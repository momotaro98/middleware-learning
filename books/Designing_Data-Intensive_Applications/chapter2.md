# Chapter 2

データモデルとクエリ言語

-----

## 2.1 リレーショナルモデルとドキュメントモデル

リレーショナルモデルはコンピューティングの歴史の中で他を圧倒してきた。

- ネットワークモデル
- 階層モデル
- オブジェクトデータベース
- XMLデータベース

注目すべきことに、RDBは非常に汎用性が高いことがわかった。SNS、eコマース、SaaSなど依然としてRDBが使われている。

-----

### 2.1.1 NoSQSの誕生

NoSQLが広まった要因

- きわめて巨大なデータセットや優れた書き込みのスループットを含む、リレーショナルで容易に実現できる以上のスケーラビリティが求められるようになったこと
- リレーショナルモデルではうまくサポートされない特殊なクエリ操作
- リレーショナルなスキーマ制約に対するフラストレーションと、もっと動的で表現力に富むデータモデルに対する欲求

-----

### 2.1.2 オブジェクトとリレーショナルのミスマッチ

オブジェクト指向(eg.Ruby)とSQLデータモデルが一致しない、インピーダンスミスマッチと呼ばれる、問題がある。ActiveRecordなどのORMは差異を完全に隠蔽できない。

ドキュメントであるような履歴書のようなデータ構造はJSONが非常に適している。

JSONでの表現は複数テーブルで構成されるスキーマに比べて、**ローカリティ**に優れている。

---

ローカリティが高い以下のようなJSONでの形式はユーザーIDから属性情報が見える。これは1対多の状態になっていると言う。

```json
{
  "user_id": 251,
  "first_name": "Bill",
  "region_id": "us:91", # IDになっている。多対1につながる。
  "education": [
    {"school_name": "Harvard University", "start": 1973, "end": 1975}
    {"school_name": "Lakeside School, Seattle", "start": null, "end": null}
  ]
}
```

-----

### 2.1.3 多対1と多対多の関係

データを正規化するためには多対1の関係が必要になるが、これはドキュメントモデルにはうまく適合しない。

-----

### 2.1.4 ドキュメントデータベースは歴史を繰り返すのか

歴史の流れ

階層モデル (JSONのようなモデル)

↓

ネットワークモデル と リレーショナルモデル が誕生

---

#### 2.1.4.1 ネットワークモデル

CODASYLモデルとも呼ばれる。

ネットワークモデルは階層モデルを一般化したもので、レコードが複数の親を持つことができる。これによって多対1や多対多の関係がモデル化できる。

ネットワークモデルのレコード間リンクはプログラミングのポインタのようなもの。レコードにアクセスするにはルートのレコードからリンクの連鎖に沿う必要があった。これを**アクセスパス**という。

---

ネットワークモデルではアクセスパスをアプリケーションが把握しておかなくてはいけない。

アクセスパスを変更する際は利用しているアプリケーションをすべて変更する必要がある。

---

#### 2.1.4.2 リレーショナルモデル

リレーショナルモデルではアクセスパスにあたる部分は利用するアプリケーションではなく、DB内のクエリオプティマイザ(実行計画)が代わりに見つけてくれる。

---

#### 2.1.4.3 ドキュメントデータベースとの比較

ドキュメントデータベースでは多対1のの表現の点では、リレーショナルと基本的に違いはない。

どちらの場合でも関連性のあるアイテムはユニークな識別子で参照される。リレーショナルでは外部キー、ドキュメントではドキュメント参照と呼ばれる。

-----

### 2.1.5 今日のリレーショナルデータベースとドキュメントデータベース

#### 2.1.5.1 アプリケーションのコードをシンプルにしてくれるデータモデルは？

* 1対多が複雑になるとき、リレーショナルは扱いづらく、ドキュメントが強み
* 多対多が頻繁になるとき、リレーショナルは扱いやすく、ドキュメントは弱み
* データ間の関係が強い場合、リレーショナルは許容範囲、ドキュメントは弱み、で**グラフモデルが最も自然になる。**

---

#### 2.1.5.2 ドキュメントモデルにおけるスキーマの柔軟性

- スキーマオンリード
  - データ構造は暗黙のものであり、データの読み取り時にのみ解釈される。
- スキーマオンライト
  - スキーマはexplicitされ、データベースは書き込まれるすべてのデータがそのスキーマに従う保証がある

---

スキーマオンリード(≒スキーマが存在しない)が"許容される"パターン

- 数多くのオブジェクトがありすべてを保存するのが現実的ではない場合
- データ構造が外部システムであり、いつ変更されるかも分からないような場合

基本的にスキーマオンライトが理想

---

#### 2.1.5.3 クエリのためのデータローカリティ

ドキュメントデータベースが得意なローカリティはパフォーマンスを上げる。しかし、ローカリティのメリットが生じるのは一度にドキュメントの大部分が必要になる場合に限られる。

---

ローカリティを活かすために関連性のあるデータ同士をグループ化しておくという着想はドキュメントモデルだけのものではない。

- Google Spanner
  - nested model
- Oracle
  - マルチテーブルインデックスクラスタテーブル
- Bigtable
  - **カラムファミリー**という概念
    - CassandraやHBaseでも使われている

--- 

#### 2.1.5.4 ドキュメント及びリレーショナルデータの融合

- 各種RDBMSがJSON方をサポートするようになった
- ドキュメントデータベースがリレーショナルな機能を持つようになった

> リレーショナルデータベースとドキュメントデータベースは、時間の経過と共に類似性が高まっているいるように見えます。これは良いことであり、それぞれのデータモデルが補完し合うことにます。ハイブリッドモデルは良い方針です。

-----

## 2.2 データのためのクエリ言語

宣言型であるSQLは命令型に対して目標をどのように達成するかは指定しない。

このことにより、簡潔であり、かつ、データベースエンジンの実装の詳細も隠蔽してくれるメリットが出る。

アプリ側のSQLの書き換えなしにデータベースが裏側でパフォーマンスの改善をすることができる。 (並列処理との相性も良い)

-----

### 2.2.1 Web上での宣言的クエリ

CSSにてHTML DOMにおける選択されているページのタイトルの背景を青にして、視覚的にハイライトにしたいとき

```css
li.selected > p {
  background-color: blue;
}
```

これは宣言的であり、JavaScriptでの命令的にfor文を回して操作するよりも優れている。

-----

### 2.2.2 MapReduceでのクエリ

**MapReduce**は、大量のデータを多くのマシンにまたがってまとめて処理するためのプログラミングモデル。

MapReduceは、宣言的なクエリと命令的なクエリAPIの中間に位置する。

---

**例**

海洋生物学者が海洋生物を見るたびにデータベースに観測レコードを追加するとする。

SQS

```sql
select date_trunc('month', observation timestamp) as observation_month,
       sum(num_animals) as total_animals
from observations
where family = 'Sharks'
group by observation month;
```

---

MongoDBのMapReduce機能

```javascript
db.observations.mapReduce(
  function () { // ②フィルタリングされたレコードをMapしていく
    var year = this.observationTimestamp.getFullYear();
    var month = this.observationTimestamp.getMonth() + 1;
    emit(year + "-" + month, this.numAnimals); // ③ [{"2022-01", 145}, {"2022-02", 118}] のようなkey=valueMap結果を返す
  },
  function reduce(key, values) { // ④ Keyごとに合計を算出する
    return Array.sum(values);
  },
  {
    query: { family: "Sharks" }, // ①はじめにフィルタリングする
    out: "monthlySharkReport" // ⑤reduceされた結果を出す
  }
);
```

---

上述のようにJavaScriptで宣言的にmap,reduce内を記述する場合はリスクがある。

MongoDB 2.2 では aggregation pipelineと呼ばれる宣言的なクエリ言語のサポートが追加された。

[これはSQLでの宣言的記述とほぼ同じ意味になる]

```javascript
db.observations.aggregate([
  { $match: { family: "Sharks" } },
  { $group: {
    id: {
      year: {$year: "$observationTimestamp"},
      month: {$year: "$observationTimestamp"}
    },
    totalAminals: {$sum: "$numAnimals"}
  }}
]);
```

------

## 2.3 グラフ型のデータモデル

<記述をスキップする>