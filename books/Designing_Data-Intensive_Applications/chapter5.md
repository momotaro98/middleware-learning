# Chapter 5

レプリケーション

-----

レプリケーションを行う理由

* データを地理的に近くに置き、レイテンシを下げるため
* 一部に障害があっても動作しつづけるよう、可用性を上げるため
* 読み取りのクエリを処理するマシン数をスケールアウトし、スループットを高めるため

-----

## 5.1 リーダー(Leader)とフォロワー(Follower)

シングルLeader

1. 1つのLeader(マスター、プライマリ)があり、DBへ書き込みしたい場合はLeaderに送信しなければいけない。
2. 他のレプリカはFollowerと呼ばれる。Leaderは新しいデータをローカルストレージに書き込むと、その変更データをレプリケーションログあるいは変更ストリームとしてすべてのFollowerに送信する。
3. クライアントがDBから読み取りをしたい場合はリーダーあるいはいずれかのFollowerにクエリを送ることができる。

-----

### 5.1.1 同期と非同期のレプリケーション

* 同期型のレプリケーションのデメリット(非同期のメリット)
  * 1つでもFollowerが反応を返さなかったとき、書き込み処理ができなくなること。
* 非同期のデメリット(同期のメリット)
  * Leaderとの一貫性が保証されていない

------

### 5.1.2 新しいFollowerのセットアップ

新しいFollowerがLeaderのデータの正確なコピーを持っていることはどのように保証できるか。

フォロワーのセットアップは整合性を保ちながらダウンタイム無しに行える。概念的には以下の手順になる。

---

1. どこかの時点でLeaderから一貫性のあるスナップショットを取る。
2. 取得したスナップショットを、新しいFollowerのノードにコピーする。

---

3. FollowerはLeaderに接続し、スナップショットが取得された後に生じたすべてのデータ変更を要求する。
   そのためには,,,**続き**。
  